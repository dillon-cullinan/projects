<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcudf: cudf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcudf
   &#160;<span id="projectnumber">0.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cudf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Invokes an instance of a functor template with the appropriate type determined by a gdf_dtype enum value.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1cuda__error.html">cuda_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a CUDA error is encountered.  <a href="structcudf_1_1cuda__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceAnd.html">DeviceAnd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceMax.html">DeviceMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceMin.html">DeviceMin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceOr.html">DeviceOr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceProduct.html">DeviceProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceSum.html">DeviceSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1DeviceXor.html">DeviceXor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when logical precondition is violated.  <a href="structcudf_1_1logic__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1table.html">table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for a set of gdf_columns of equal number of rows.  <a href="structcudf_1_1table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8c6e344a72404039eef838a8cb39295b"><td class="memItemLeft" align="right" valign="top"><a id="a8c6e344a72404039eef838a8cb39295b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>category</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_category, GDF_CATEGORY &gt;</td></tr>
<tr class="separator:a8c6e344a72404039eef838a8cb39295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64847ffcf8f0ad4069085490f9fb5c"><td class="memItemLeft" align="right" valign="top"><a id="a9b64847ffcf8f0ad4069085490f9fb5c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>nvstring_category</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_nvstring_category, GDF_STRING_CATEGORY &gt;</td></tr>
<tr class="separator:a9b64847ffcf8f0ad4069085490f9fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6916ffd2fdcad20b769afc3d4130140e"><td class="memItemLeft" align="right" valign="top"><a id="a6916ffd2fdcad20b769afc3d4130140e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_timestamp, GDF_TIMESTAMP &gt;</td></tr>
<tr class="separator:a6916ffd2fdcad20b769afc3d4130140e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788a6ac25db35f51d612644bebd86970"><td class="memItemLeft" align="right" valign="top"><a id="a788a6ac25db35f51d612644bebd86970"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>date32</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_date32, GDF_DATE32 &gt;</td></tr>
<tr class="separator:a788a6ac25db35f51d612644bebd86970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da9e96ba9d677a713403fb3704600ef"><td class="memItemLeft" align="right" valign="top"><a id="a5da9e96ba9d677a713403fb3704600ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>date64</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_date64, GDF_DATE64 &gt;</td></tr>
<tr class="separator:a5da9e96ba9d677a713403fb3704600ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2916a984683be11ca496ae1535849cb3"><td class="memItemLeft" align="right" valign="top"><a id="a2916a984683be11ca496ae1535849cb3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bool8</b> = <a class="el" href="structcudf_1_1detail_1_1wrapper.html">detail::wrapper</a>&lt; gdf_bool8, GDF_BOOL8 &gt;</td></tr>
<tr class="separator:a2916a984683be11ca496ae1535849cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="memItemLeft" align="right" valign="top">rmm::device_vector&lt; bit_mask::bit_mask_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aec006bc00092dd8ec47f2c7ca6fe01d4">row_bitmask</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a bitmask indicating the presence of NULL values in rows of a table.  <a href="#aec006bc00092dd8ec47f2c7ca6fe01d4">More...</a><br /></td></tr>
<tr class="separator:aec006bc00092dd8ec47f2c7ca6fe01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206ad1cc4b21f7f14c5d5f7d304efbda"><td class="memItemLeft" align="right" valign="top"><a id="a206ad1cc4b21f7f14c5d5f7d304efbda"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><b>empty_like</b> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input)</td></tr>
<tr class="separator:a206ad1cc4b21f7f14c5d5f7d304efbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ad9c7f685b0dab321f4e55acfb0776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a29ad9c7f685b0dab321f4e55acfb0776">allocate_like</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:a29ad9c7f685b0dab321f4e55acfb0776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new column of the same size and type as the input.  <a href="#a29ad9c7f685b0dab321f4e55acfb0776">More...</a><br /></td></tr>
<tr class="separator:a29ad9c7f685b0dab321f4e55acfb0776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aa7e6bf39cb5dd5cdb370d0a562675922">copy</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const  &amp;input, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column that is a copy of input.  <a href="#aa7e6bf39cb5dd5cdb370d0a562675922">More...</a><br /></td></tr>
<tr class="separator:aa7e6bf39cb5dd5cdb370d0a562675922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3588fc0b833a8f2d7213651a05f48c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a3588fc0b833a8f2d7213651a05f48c80">empty_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t)</td></tr>
<tr class="memdesc:a3588fc0b833a8f2d7213651a05f48c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of empty columns with the same types as the inputs.  <a href="#a3588fc0b833a8f2d7213651a05f48c80">More...</a><br /></td></tr>
<tr class="separator:a3588fc0b833a8f2d7213651a05f48c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8927039e4f9ea22fc66feeb9b5f13e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#af8927039e4f9ea22fc66feeb9b5f13e8">allocate_like</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:af8927039e4f9ea22fc66feeb9b5f13e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns with the same type and allocation size as the input.  <a href="#af8927039e4f9ea22fc66feeb9b5f13e8">More...</a><br /></td></tr>
<tr class="separator:af8927039e4f9ea22fc66feeb9b5f13e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1table.html">table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a9fae65b5e23d13aec03edef7a8aeacb0">copy</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  &amp;t, cudaStream_t stream=0)</td></tr>
<tr class="memdesc:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of columns and deep copies the data from an input table.  <a href="#a9fae65b5e23d13aec03edef7a8aeacb0">More...</a><br /></td></tr>
<tr class="separator:a9fae65b5e23d13aec03edef7a8aeacb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f762fbe22ea8e824e426d3880b085a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a03f762fbe22ea8e824e426d3880b085a">gather</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, gdf_index_type const gather_map[], <a class="el" href="structcudf_1_1table.html">table</a> *destination_table)</td></tr>
<tr class="memdesc:a03f762fbe22ea8e824e426d3880b085a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the rows (including null values) of a set of source columns into a set of destination columns.  <a href="#a03f762fbe22ea8e824e426d3880b085a">More...</a><br /></td></tr>
<tr class="separator:a03f762fbe22ea8e824e426d3880b085a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30995b318ebee41f1ab8e79dc2527c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ac30995b318ebee41f1ab8e79dc2527c0">scatter</a> (<a class="el" href="structcudf_1_1table.html">table</a> const  *source_table, gdf_index_type const scatter_map[], <a class="el" href="structcudf_1_1table.html">table</a> *destination_table)</td></tr>
<tr class="memdesc:ac30995b318ebee41f1ab8e79dc2527c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows (including null values) of a set of source columns into a set of destination columns.  <a href="#ac30995b318ebee41f1ab8e79dc2527c0">More...</a><br /></td></tr>
<tr class="separator:ac30995b318ebee41f1ab8e79dc2527c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f4a85729765c154b21d8102be5a9d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a31f4a85729765c154b21d8102be5a9d5">slice</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input_column, gdf_index_type const  *indices, gdf_size_type num_indices)</td></tr>
<tr class="memdesc:a31f4a85729765c154b21d8102be5a9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a column (including null values) into a set of columns according to a set of indices.  <a href="#a31f4a85729765c154b21d8102be5a9d5">More...</a><br /></td></tr>
<tr class="separator:a31f4a85729765c154b21d8102be5a9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69299f48fdcd25864a2f560e55d18ea9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a69299f48fdcd25864a2f560e55d18ea9">split</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input_column, gdf_index_type const  *indices, gdf_size_type num_indices)</td></tr>
<tr class="memdesc:a69299f48fdcd25864a2f560e55d18ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a column (including null values) into a set of columns according to a set of indices.  <a href="#a69299f48fdcd25864a2f560e55d18ea9">More...</a><br /></td></tr>
<tr class="separator:a69299f48fdcd25864a2f560e55d18ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d269210347c80b2a841daef1a0d136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__scalar.html">gdf_scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a16d269210347c80b2a841daef1a0d136">reduction</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *col, gdf_reduction_op op, gdf_dtype output_dtype)</td></tr>
<tr class="memdesc:a16d269210347c80b2a841daef1a0d136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision <code>dtype</code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> will contain <code>false</code>.  <a href="#a16d269210347c80b2a841daef1a0d136">More...</a><br /></td></tr>
<tr class="separator:a16d269210347c80b2a841daef1a0d136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a65546aa9c42e87334fb5e1e3f274bc6b">scan</a> (const <a class="el" href="structgdf__column__.html">gdf_column</a> *input, <a class="el" href="structgdf__column__.html">gdf_column</a> *output, gdf_scan_op op, bool inclusive)</td></tr>
<tr class="memdesc:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null.  <a href="#a65546aa9c42e87334fb5e1e3f274bc6b">More...</a><br /></td></tr>
<tr class="separator:a65546aa9c42e87334fb5e1e3f274bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd8efbc412d65aa608e7ac19eeb3574"><td class="memItemLeft" align="right" valign="top"><a id="affd8efbc412d65aa608e7ac19eeb3574"></a>
<a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rolling_window</b> (const <a class="el" href="structgdf__column__.html">gdf_column</a> &amp;input_col, gdf_size_type window, gdf_size_type min_periods, gdf_size_type forward_window, gdf_agg_op agg_type, const gdf_size_type *window_col, const gdf_size_type *min_periods_col, const gdf_size_type *forward_window_col, cudaStream_t stream)</td></tr>
<tr class="separator:affd8efbc412d65aa608e7ac19eeb3574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fba636792abcf96032c639873d14870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a5fba636792abcf96032c639873d14870">apply_boolean_mask</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input, <a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;boolean_mask)</td></tr>
<tr class="memdesc:a5fba636792abcf96032c639873d14870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a column using a column of boolean values as a mask.  <a href="#a5fba636792abcf96032c639873d14870">More...</a><br /></td></tr>
<tr class="separator:a5fba636792abcf96032c639873d14870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb8b53ebafc4439711c5fbb4d31a89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgdf__column__.html">gdf_column</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a2cb8b53ebafc4439711c5fbb4d31a89b">drop_nulls</a> (<a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;input)</td></tr>
<tr class="memdesc:a2cb8b53ebafc4439711c5fbb4d31a89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a column to remove null elements.  <a href="#a2cb8b53ebafc4439711c5fbb4d31a89b">More...</a><br /></td></tr>
<tr class="separator:a2cb8b53ebafc4439711c5fbb4d31a89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; gdf_dtype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad2f973d94c67ab3dc1a183c5adb3753d">column_dtypes</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of the dtypes of the columns in a table.  <a href="#ad2f973d94c67ab3dc1a183c5adb3753d">More...</a><br /></td></tr>
<tr class="separator:ad2f973d94c67ab3dc1a183c5adb3753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada393acb565321d740f2b9950ffe2941"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ada393acb565321d740f2b9950ffe2941">has_nulls</a> (<a class="el" href="structcudf_1_1table.html">cudf::table</a> const  &amp;<a class="el" href="structcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ada393acb565321d740f2b9950ffe2941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a table contains any null values.  <a href="#ada393acb565321d740f2b9950ffe2941">More...</a><br /></td></tr>
<tr class="separator:ada393acb565321d740f2b9950ffe2941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62151c46119cd04dc146c9e4175375f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename BinaryOp &gt; </td></tr>
<tr class="memitem:ae62151c46119cd04dc146c9e4175375f"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ae62151c46119cd04dc146c9e4175375f">genericAtomicOperation</a> (T *address, T const &amp;update_value, <a class="el" href="structBinaryOp.html">BinaryOp</a> op)</td></tr>
<tr class="memdesc:ae62151c46119cd04dc146c9e4175375f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes '<a class="el" href="structBinaryOp.html">BinaryOp</a>'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction.  <a href="#ae62151c46119cd04dc146c9e4175375f">More...</a><br /></td></tr>
<tr class="separator:ae62151c46119cd04dc146c9e4175375f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memTemplParams" colspan="2"><a id="acafbd5dbae09b26c92b964e0122d5fc9"></a>
template&lt;typename BinaryOp &gt; </td></tr>
<tr class="memitem:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memTemplItemLeft" align="right" valign="top">__forceinline__ __device__ <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genericAtomicOperation</b> (<a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a> *address, <a class="el" href="structcudf_1_1detail_1_1wrapper.html">cudf::bool8</a> const &amp;update_value, <a class="el" href="structBinaryOp.html">BinaryOp</a> op)</td></tr>
<tr class="separator:acafbd5dbae09b26c92b964e0122d5fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c70f497e88c7cf01dff98c594f0ec51"><td class="memTemplParams" colspan="2"><a id="a9c70f497e88c7cf01dff98c594f0ec51"></a>
template&lt;class functor_t , typename... Ts&gt; </td></tr>
<tr class="memitem:a9c70f497e88c7cf01dff98c594f0ec51"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) CUDA_HOST_DEVICE_CALLABLE&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_dispatcher</b> (gdf_dtype dtype, functor_t f, Ts &amp;&amp;... args)</td></tr>
<tr class="separator:a9c70f497e88c7cf01dff98c594f0ec51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ad7b0f1bc518e47eaa2cfdd0ec88e3989">gdf_dtype_of</a> ()</td></tr>
<tr class="memdesc:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to it's corresponding gdf_dtype.  <a href="#ad7b0f1bc518e47eaa2cfdd0ec88e3989">More...</a><br /></td></tr>
<tr class="separator:ad7b0f1bc518e47eaa2cfdd0ec88e3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memTemplParams" colspan="2"><a id="ad0a0a98fdfe7a302afb2dfcaeb536412"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int8_t &gt;</b> ()</td></tr>
<tr class="separator:ad0a0a98fdfe7a302afb2dfcaeb536412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d"><td class="memTemplParams" colspan="2"><a id="ae3d9564b2dc03eee3515499cae68827d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae3d9564b2dc03eee3515499cae68827d"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int16_t &gt;</b> ()</td></tr>
<tr class="separator:ae3d9564b2dc03eee3515499cae68827d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memTemplParams" colspan="2"><a id="ae5ac9bfed0ac9684cc5c201271d4bca5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int32_t &gt;</b> ()</td></tr>
<tr class="separator:ae5ac9bfed0ac9684cc5c201271d4bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memTemplParams" colspan="2"><a id="a17d6aab829fdfa0a8e805693fe6d0682"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; int64_t &gt;</b> ()</td></tr>
<tr class="separator:a17d6aab829fdfa0a8e805693fe6d0682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124"><td class="memTemplParams" colspan="2"><a id="aef0bacd5dab94476140d35bd1a44c124"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aef0bacd5dab94476140d35bd1a44c124"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; float &gt;</b> ()</td></tr>
<tr class="separator:aef0bacd5dab94476140d35bd1a44c124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac"><td class="memTemplParams" colspan="2"><a id="aa02973e71d09dc7a3636d2a836968dac"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa02973e71d09dc7a3636d2a836968dac"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; double &gt;</b> ()</td></tr>
<tr class="separator:aa02973e71d09dc7a3636d2a836968dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5"><td class="memTemplParams" colspan="2"><a id="ab49efe66b146dc87425669653bde18f5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab49efe66b146dc87425669653bde18f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::bool8 &gt;</b> ()</td></tr>
<tr class="separator:ab49efe66b146dc87425669653bde18f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memTemplParams" colspan="2"><a id="a1e1b828c8f1b2b46e015afb85902ba52"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::date32 &gt;</b> ()</td></tr>
<tr class="separator:a1e1b828c8f1b2b46e015afb85902ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c"><td class="memTemplParams" colspan="2"><a id="adb20c98631c4c203372547135f13732c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adb20c98631c4c203372547135f13732c"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::date64 &gt;</b> ()</td></tr>
<tr class="separator:adb20c98631c4c203372547135f13732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memTemplParams" colspan="2"><a id="ad2576f3b441a5f87a0d5b67b7d21b854"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::timestamp &gt;</b> ()</td></tr>
<tr class="separator:ad2576f3b441a5f87a0d5b67b7d21b854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memTemplParams" colspan="2"><a id="a4e807d272b4582ff4d2a0dd9c6b8b309"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::category &gt;</b> ()</td></tr>
<tr class="separator:a4e807d272b4582ff4d2a0dd9c6b8b309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919"><td class="memTemplParams" colspan="2"><a id="a0f831e82c6b13cd54c940e74fc46b919"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0f831e82c6b13cd54c940e74fc46b919"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; cudf::nvstring_category &gt;</b> ()</td></tr>
<tr class="separator:a0f831e82c6b13cd54c940e74fc46b919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606"><td class="memTemplParams" colspan="2"><a id="a5d1e00fa2d40d07ed6114dc064582606"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5d1e00fa2d40d07ed6114dc064582606"><td class="memTemplItemLeft" align="right" valign="top">constexpr gdf_dtype&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gdf_dtype_of&lt; NVStrings &gt;</b> ()</td></tr>
<tr class="separator:a5d1e00fa2d40d07ed6114dc064582606"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Invokes an instance of a functor template with the appropriate type determined by a gdf_dtype enum value. </p>
<p>This helper function accepts any object with an "operator()" template, e.g., a functor. It will invoke an instance of the template by passing in as the template argument an appropriate type determined by the value of the gdf_dtype argument.</p>
<p>The template may have 1 or more template parameters, but the first parameter must be the type dispatched from the gdf_dtype enum. The remaining template parameters must be able to be automatically deduced.</p>
<p>There is a 1-to-1 mapping of gdf_dtype enum values and dispatched types. However, different gdf_dtype values may have the same underlying type. Therefore, in order to provide the 1-to-1 mapping, a wrapper struct may be dispatched for certain gdf_dtype enum values in order to emulate a "strong
typedef".</p>
<p>A strong typedef provides a new, concrete type unlike a normal C++ typedef which is simply a type alias. These "strong typedef" structs simply wrap a single member variable of a fundamental type called 'value'.</p>
<p>The standard arithmetic operators are defined for the wrapper structs and therefore the wrapper struct types can be used as if they were fundamental types.</p>
<p>See <a class="el" href="wrapper__types_8hpp.html" title="Wrapper structs for for the non-fundamental gdf_dtype types. ">wrapper_types.hpp</a> for more detail.</p>
<p>Example usage with a functor that returns the size of the dispatched type:</p>
<p>struct example_functor{ template &lt;typename t&gt;=""&gt; int operator()(){ return sizeof(T); } };</p>
<p>cudf::type_dispatcher(GDF_INT8, example_functor); // returns 1 cudf::type_dispatcher(GDF_INT64, example_functor); // returns 8</p>
<p>Example usage of a functor for checking if element "i" in column "lhs" is equal to element "j" in column "rhs":</p>
<p>struct elements_are_equal{ template &lt;typename columntype&gt;=""&gt; bool operator()(void const * lhs, int i, void const * rhs, int j) { // Cast the void* data buffer to the dispatched type and retrieve elements // "i" and "j" from the respective columns ColumnType const i_elem = static_cast&lt;ColumnType const*&gt;(lhs)[i]; ColumnType const j_elem = static_cast&lt;ColumnType const*&gt;(rhs)[j];</p>
<p>// operator== is defined for wrapper structs such that it performs the // operator== on the underlying values. Therefore, the wrapper structs // can be used as if they were fundamental arithmetic types return i_elem == j_elem; } };</p>
<p>The return type for all template instantiations of the functor's "operator()" lambda must be the same, else there will be a compiler error as you would be trying to return different types from the same function.</p>
<p>NOTE: It is undefined behavior if an unsupported or invalid <code>gdf_dtype</code> is supplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The gdf_dtype enum that determines which type will be dispatched </td></tr>
    <tr><td class="paramname">f</td><td>The functor with a templated "operator()" that will be invoked with the dispatched type </td></tr>
    <tr><td class="paramname">args</td><td>A parameter-pack (i.e., arbitrary number of arguments) that will be perfectly-forwarded as the arguments of the functor's "operator()".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whatever is returned by the functor's "operator()". </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a29ad9c7f685b0dab321f4e55acfb0776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ad9c7f685b0dab321f4e55acfb0776">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new column of the same size and type as the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to emulate </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column An allocated column of same size and type of input </dd></dl>

</div>
</div>
<a id="af8927039e4f9ea22fc66feeb9b5f13e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8927039e4f9ea22fc66feeb9b5f13e8">&#9670;&nbsp;</a></span>allocate_like() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns with the same type and allocation size as the input. </p>
<p>------------------------------------------------------------------------&mdash;* Creates the <code>gdf_column</code> objects, and allocates underlying device memory for each column matching the input columns</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to emulate </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform allocations <h2>table A table of columns with same type and allocation size as input </h2>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fba636792abcf96032c639873d14870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fba636792abcf96032c639873d14870">&#9670;&nbsp;</a></span>apply_boolean_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::apply_boolean_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a column using a column of boolean values as a mask. </p>
<p>Given an input column and a mask column, an element <code>i</code> from the input column is copied to the output if the corresponding element <code>i</code> in the mask is non-null and <code>true</code>. This operation is stable: the input order is preserved.</p>
<p>The input and mask columns must be of equal size.</p>
<p>The output column has size equal to the number of elements in boolean_mask that are both non-null and <code>true</code>. Note that the output column memory is allocated by this function but must be freed by the caller when finished.</p>
<dl class="section note"><dt>Note</dt><dd>that the <code>boolean_mask</code> may have just boolean data (no valid bitmask), or just a valid bitmask (no boolean data), or it may have both. The filter adapts to these three situations.</dd>
<dd>
if <code>input.size</code> is zero, there is no error, and an empty column is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>A column of type GDF_BOOL8 used as a mask to filter the input column corresponding index passes the filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column containing copy of all elements of <code>input</code> passing the filter defined by <code>boolean_mask</code>. </dd></dl>

</div>
</div>
<a id="ad2f973d94c67ab3dc1a183c5adb3753d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f973d94c67ab3dc1a183c5adb3753d">&#9670;&nbsp;</a></span>column_dtypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; gdf_dtype &gt; cudf::column_dtypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of the dtypes of the columns in a table. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to get the column dtypes from <h2>std::vector&lt;gdf_dtype&gt; </h2>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7e6bf39cb5dd5cdb370d0a562675922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e6bf39cb5dd5cdb370d0a562675922">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column that is a copy of input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column to copy </td></tr>
    <tr><td class="paramname">stream</td><td>Optional stream in which to perform copies </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column A copy of input </dd></dl>

</div>
</div>
<a id="a9fae65b5e23d13aec03edef7a8aeacb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fae65b5e23d13aec03edef7a8aeacb0">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of columns and deep copies the data from an input table. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to free each column's device memory allocation in addition to deleting the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td></td></tr>
    <tr><td class="paramname">stream</td><td><h2>table </h2>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cb8b53ebafc4439711c5fbb4d31a89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb8b53ebafc4439711c5fbb4d31a89b">&#9670;&nbsp;</a></span>drop_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__column__.html">gdf_column</a> cudf::drop_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a column to remove null elements. </p>
<p>Given an input column an element <code>i</code> from the input column is copied to the output if the corresponding element <code>i</code> in the input's valid bitmask is non-null.</p>
<p>The output column has size equal to the number of elements in boolean_mask that are both non-null and <code>true</code>. Note that the output column memory is allocated by this function but must be freed by the caller when finished.</p>
<p>If the input column is not nullable, this function just copies the input to the output.</p>
<ul>
<li><dl class="section note"><dt>Note</dt><dd>if <code>input.size</code> is zero, there is no error, and an empty column is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column to filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gdf_column Column containing copy of all non-null elements of <code>input</code>. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a3588fc0b833a8f2d7213651a05f48c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3588fc0b833a8f2d7213651a05f48c80">&#9670;&nbsp;</a></span>empty_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1table.html">table</a> cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of empty columns with the same types as the inputs. </p>
<p>------------------------------------------------------------------------&mdash;* Creates the <code>gdf_column</code> objects, but does not allocate any underlying device memory for the column's data or bitmask.</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to delete the <code>gdf_column</code> object for every column in the new table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input table to emulate <h2>table A table of empty columns of same type as input </h2>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03f762fbe22ea8e824e426d3880b085a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f762fbe22ea8e824e426d3880b085a">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const&#160;</td>
          <td class="paramname"><em>gather_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> *&#160;</td>
          <td class="paramname"><em>destination_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the rows (including null values) of a set of source columns into a set of destination columns. </p>
<p>The two sets of columns must have equal numbers of columns.</p>
<p>Gathers the rows of the source columns into the destination columns according to a gather map such that row "i" in the destination columns will contain row "gather_map[i]" from the source columns.</p>
<p>The datatypes between coresponding columns in the source and destination columns must be the same.</p>
<p>The number of elements in the gather_map must equal the number of rows in the destination columns.</p>
<p>If any index in the gather_map is outside the range [0, num rows in source_columns), the result is undefined.</p>
<p>If the same index appears more than once in gather_map, the result is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>An array of indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination_table</td><td>A preallocated set of columns with a number of rows equal in size to the number of elements in the gather_map that will contain the rearrangement of the source columns based on the mapping. Can be the same as <code>source_table</code> (in-place gather).</td></tr>
  </table>
  </dd>
</dl>
<p>GDF_SUCCESS upon successful completion </p>

</div>
</div>
<a id="ad7b0f1bc518e47eaa2cfdd0ec88e3989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b0f1bc518e47eaa2cfdd0ec88e3989">&#9670;&nbsp;</a></span>gdf_dtype_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr gdf_dtype cudf::gdf_dtype_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a C++ type to it's corresponding gdf_dtype. </p>
<p>------------------------------------------------------------------------&mdash;* When explicitly passed a template argument of a given type, returns the appropriate <code>gdf_dtype</code> for the specified C++ type.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> gdf_dtype_of&lt;int32_t&gt;();        <span class="comment">// Returns GDF_INT32</span></div><div class="line"><span class="keywordflow">return</span> gdf_dtype_of&lt;cudf::category&gt;(); <span class="comment">// Returns GDF_CATEGORY</span></div></div><!-- fragment --><h2>T The type to map to a <code>gdf_dtype</code> </h2>

</div>
</div>
<a id="ae62151c46119cd04dc146c9e4175375f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62151c46119cd04dc146c9e4175375f">&#9670;&nbsp;</a></span>genericAtomicOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__forceinline__ __device__ T cudf::genericAtomicOperation </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>update_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryOp.html">BinaryOp</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute atomic binary operation reads the <code>old</code> located at the <code>address</code> in global or shared memory, computes '<a class="el" href="structBinaryOp.html">BinaryOp</a>'('old', 'update_value'), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. </p>
<p>----------------------------------------------------------------------&mdash;* The supported cudf types for <code>genericAtomicOperation</code> are: int8_t, int16_t, int32_t, int64_t, float, double, cudf::date32, cudf::date64, cudf::timestamp, cudf::category, cudf::nvstring_category, cudf::bool8</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address of old value in global or shared memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The binary operator used for compute</td></tr>
  </table>
  </dd>
</dl>
<h2>The old value at <code>address</code> </h2>

</div>
</div>
<a id="ada393acb565321d740f2b9950ffe2941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada393acb565321d740f2b9950ffe2941">&#9670;&nbsp;</a></span>has_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::has_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if a table contains any null values. </p>
<p>------------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to check for null values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the table contains one or more null values <h2>false If the table contains zero null values </h2>
</dd></dl>

</div>
</div>
<a id="a16d269210347c80b2a841daef1a0d136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d269210347c80b2a841daef1a0d136">&#9670;&nbsp;</a></span>reduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgdf__scalar.html">gdf_scalar</a> cudf::reduction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_reduction_op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_dtype&#160;</td>
          <td class="paramname"><em>output_dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the reduction of the values in all rows of a column This function does not detect overflows in reductions. Using a higher precision <code>dtype</code> may prevent overflow. Only <code>min</code> and <code>max</code> ops are supported for reduction of non-arithmetic types (date32, timestamp, category...). The null values are skipped for the operation. If the column is empty, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> will contain <code>false</code>. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>Input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operator applied by the reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtype</td><td>The computation and output precision. <code>dtype</code> must be a data type that is convertible from the input dtype. If the input column has arithmetic type, any arithmetic type can be specified. If the input column has non-arithmetic type (date32, timestamp, category...), the same type must be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> the result value If the reduction fails, the member is_valid of the output <a class="el" href="structgdf__scalar.html" title="A struct to hold a scalar (single) value and its type information. ">gdf_scalar</a> <h2>will contain <code>false</code>. </h2>
</dd></dl>

</div>
</div>
<a id="aec006bc00092dd8ec47f2c7ca6fe01d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec006bc00092dd8ec47f2c7ca6fe01d4">&#9670;&nbsp;</a></span>row_bitmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_vector&lt; bit_mask::bit_mask_t &gt; cudf::row_bitmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">cudf::table</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a bitmask indicating the presence of NULL values in rows of a table. </p>
<p>------------------------------------------------------------------------&mdash;* If a row <code>i</code> in <code>table</code> contains one or more NULL values, then bit <code>i</code> in the returned bitmask will be 0.</p>
<p>Otherwise, bit <code>i</code> will be 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to compute the row bitmask of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bit_mask::bit_mask_t* The bitmask indicating the presence of NULLs in <h2>a row </h2>
</dd></dl>

</div>
</div>
<a id="a65546aa9c42e87334fb5e1e3f274bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65546aa9c42e87334fb5e1e3f274bc6b">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::scan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_scan_op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the scan (a.k.a. prefix sum) of a column. The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null. </p>
<p>-----------------------------------------------------------------------&mdash;* </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column for the san </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The pre-allocated output column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation of the scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inclusive</td><td>The flag for applying an inclusive scan if true, <h2>an exclusive scan if false. </h2>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac30995b318ebee41f1ab8e79dc2527c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30995b318ebee41f1ab8e79dc2527c0">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> const *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const&#160;</td>
          <td class="paramname"><em>scatter_map</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1table.html">table</a> *&#160;</td>
          <td class="paramname"><em>destination_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows (including null values) of a set of source columns into a set of destination columns. </p>
<p>The two sets of columns must have equal numbers of columns.</p>
<p>Scatters the rows of the source columns into the destination columns according to a scatter map such that row "i" from the source columns will be scattered to row "scatter_map[i]" in the destination columns.</p>
<p>The datatypes between coresponding columns in the source and destination columns must be the same.</p>
<p>The number of elements in the scatter_map must equal the number of rows in the source columns.</p>
<p>If any index in scatter_map is outside the range of [0, num rows in destination_columns), the result is undefined.</p>
<p>If the same index appears more than once in scatter_map, the result is undefined.</p>
<p>[in] source_table The columns whose rows will be scattered [in] scatter_map An array that maps rows in the input columns to rows in the output columns. [out] destination_table A preallocated set of columns with a number of rows equal in size to the maximum index contained in scatter_map</p>
<p>GDF_SUCCESS upon successful completion </p>

</div>
</div>
<a id="a31f4a85729765c154b21d8102be5a9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f4a85729765c154b21d8102be5a9d5">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt; cudf::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>num_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices a column (including null values) into a set of columns according to a set of indices. </p>
<p>The "slice" function divides part of the input column into multiple intervals of rows using the indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.</p>
<p>The pairs of indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.</p>
<p>Exceptional cases for the indices array are: When the values in the pair are equal, the function returns an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.</p>
<p>The output columns will be allocated by the function.</p>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} indices: {1, 3, 5, 9, 2, 4, 8, 8} output: {{12, 14}, {20, 22, 24, 26}, {14, 16}, {}}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_column</td><td>The input column whose rows will be sliced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>An device array of indices that are used to take 'slices' of the input column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of gdf_column*, each of which may have a different number of rows. a different number of rows that are equal to the difference of two consecutive indices in the indices array. </dd></dl>

</div>
</div>
<a id="a69299f48fdcd25864a2f560e55d18ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69299f48fdcd25864a2f560e55d18ea9">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structgdf__column__.html">gdf_column</a> * &gt; cudf::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgdf__column__.html">gdf_column</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_index_type const *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gdf_size_type&#160;</td>
          <td class="paramname"><em>num_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a column (including null values) into a set of columns according to a set of indices. </p>
<p>The "split" function divides the input column into multiple intervals of rows using the indices values and it stores the intervals into the output columns. Regarding the interval of indices, a pair of values are taken from the indices array in a consecutive manner. The pair of indices are left-closed and right-open.</p>
<p>The indices array ('indices') is require to be a monotonic non-decreasing set. The indices in the array are required to comply with the following conditions: a, b belongs to Range[0, input column size] a &lt;= b, where the position of a is less or equal to the position of b.</p>
<p>The split function will take a pair of indices from the indices array ('indices') in a consecutive manner. For the first pair, the function will take the value 0 and the first element of the indices array. For the last pair, the function will take the last element of the indices array and the size of the input column.</p>
<p>Exceptional cases for the indices array are: When the values in the pair are equal, the function return an empty column. When the values in the pair are 'strictly decreasing', the outcome is undefined. When any of the values in the pair don't belong to the range[0, input column size), the outcome is undefined. When the indices array is empty, an empty vector of columns is returned.</p>
<p>It is required that the output columns will be preallocated. The size of each of the columns can be of different value. The number of columns must be equal to the number of indices in the array plus one. The datatypes of the input column and the output columns must be the same.</p>
<p>Example: input: {10, 12, 14, 16, 18, 20, 22, 24, 26, 28} indices: {2, 5, 9} output: {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_column</td><td>The input column whose rows will be split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>An device array of indices that are used to divide the input column into multiple columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of gdf_column*, each of which may have a different size a different number of rows. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
